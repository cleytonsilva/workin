/**
 * WorkIn Extension - Integration Test
 * Teste de integra√ß√£o para verificar o fluxo completo
 */

class WorkInIntegrationTest {
  constructor() {
    this.testResults = [];
    this.isRunning = false;
  }

  /**
   * Executa todos os testes de integra√ß√£o
   */
  async runAllTests() {
    if (this.isRunning) {
      console.log('Teste j√° em execu√ß√£o');
      return;
    }

    this.isRunning = true;
    this.testResults = [];

    console.log('üöÄ Iniciando testes de integra√ß√£o WorkIn...');

    try {
      // Teste 1: Verificar m√≥dulos carregados
      await this.testModuleLoading();

      // Teste 2: Verificar configura√ß√µes
      await this.testConfiguration();

      // Teste 3: Verificar seguran√ßa
      await this.testSafetyChecks();

      // Teste 4: Verificar comunica√ß√£o entre m√≥dulos
      await this.testModuleCommunication();

      // Teste 5: Verificar storage
      await this.testStorageOperations();

      // Teste 6: Verificar UI
      await this.testUIComponents();

      // Relat√≥rio final
      this.generateReport();

    } catch (error) {
      console.error('‚ùå Erro durante testes:', error);
      this.addTestResult('ERRO_GERAL', false, error.message);
    } finally {
      this.isRunning = false;
    }
  }

  /**
   * Testa carregamento de m√≥dulos
   */
  async testModuleLoading() {
    console.log('üì¶ Testando carregamento de m√≥dulos...');

    const modules = [
      { name: 'WorkInJobScraper', obj: window.WorkInJobScraper },
      { name: 'WorkInSafetyManager', obj: window.WorkInSafetyManager },
      { name: 'WorkInUtils', obj: window.WorkInUtils }
    ];

    for (const module of modules) {
      const loaded = module.obj !== undefined;
      this.addTestResult(`MODULE_${module.name}`, loaded, 
        loaded ? 'M√≥dulo carregado' : 'M√≥dulo n√£o encontrado');
    }
  }

  /**
   * Testa configura√ß√µes
   */
  async testConfiguration() {
    console.log('‚öôÔ∏è Testando configura√ß√µes...');

    try {
      // Verificar manifest
      const manifest = chrome.runtime.getManifest();
      const hasRequiredPermissions = manifest.permissions.includes('scripting') &&
                                   manifest.permissions.includes('tabs') &&
                                   manifest.permissions.includes('storage');

      this.addTestResult('MANIFEST_PERMISSIONS', hasRequiredPermissions,
        hasRequiredPermissions ? 'Permiss√µes corretas' : 'Permiss√µes faltando');

      // Verificar content scripts
      const hasContentScripts = manifest.content_scripts && 
                               manifest.content_scripts.length > 0;

      this.addTestResult('CONTENT_SCRIPTS', hasContentScripts,
        hasContentScripts ? 'Content scripts configurados' : 'Content scripts faltando');

    } catch (error) {
      this.addTestResult('CONFIGURATION', false, error.message);
    }
  }

  /**
   * Testa verifica√ß√µes de seguran√ßa
   */
  async testSafetyChecks() {
    console.log('üîí Testando verifica√ß√µes de seguran√ßa...');

    if (!window.WorkInSafetyManager) {
      this.addTestResult('SAFETY_MANAGER', false, 'SafetyManager n√£o carregado');
      return;
    }

    try {
      const safetyCheck = await window.WorkInSafetyManager.checkSafety('test');
      
      this.addTestResult('SAFETY_CHECK', true, 
        `Verifica√ß√£o de seguran√ßa: ${safetyCheck.safe ? 'OK' : safetyCheck.reason}`);

      // Testar registro de opera√ß√£o
      await window.WorkInSafetyManager.recordOperation('test', { test: true });
      
      this.addTestResult('SAFETY_RECORD', true, 'Opera√ß√£o registrada com sucesso');

    } catch (error) {
      this.addTestResult('SAFETY_CHECKS', false, error.message);
    }
  }

  /**
   * Testa comunica√ß√£o entre m√≥dulos
   */
  async testModuleCommunication() {
    console.log('üì° Testando comunica√ß√£o entre m√≥dulos...');

    try {
      // Testar comunica√ß√£o com service worker
      const response = await chrome.runtime.sendMessage({ action: 'getSettings' });
      
      this.addTestResult('SERVICE_WORKER_COMM', response !== undefined,
        response ? 'Comunica√ß√£o com SW OK' : 'Falha na comunica√ß√£o');

      // Testar comunica√ß√£o com content script (se estivermos em uma aba)
      const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
      
      if (tab && tab.url.includes('linkedin.com')) {
        try {
          const contentResponse = await chrome.tabs.sendMessage(tab.id, { 
            action: 'getCollectionStatus' 
          });
          
          this.addTestResult('CONTENT_SCRIPT_COMM', true, 
            'Comunica√ß√£o com content script OK');
        } catch (error) {
          this.addTestResult('CONTENT_SCRIPT_COMM', false, 
            'Falha na comunica√ß√£o com content script');
        }
      } else {
        this.addTestResult('CONTENT_SCRIPT_COMM', true, 
          'N√£o em p√°gina do LinkedIn - teste ignorado');
      }

    } catch (error) {
      this.addTestResult('MODULE_COMMUNICATION', false, error.message);
    }
  }

  /**
   * Testa opera√ß√µes de storage
   */
  async testStorageOperations() {
    console.log('üíæ Testando opera√ß√µes de storage...');

    try {
      // Testar escrita
      const testData = { test: true, timestamp: Date.now() };
      await chrome.storage.local.set({ integrationTest: testData });

      // Testar leitura
      const result = await chrome.storage.local.get(['integrationTest']);
      
      const writeReadOK = result.integrationTest && 
                         result.integrationTest.test === true;

      this.addTestResult('STORAGE_WRITE_READ', writeReadOK,
        writeReadOK ? 'Storage OK' : 'Falha no storage');

      // Limpar dados de teste
      await chrome.storage.local.remove(['integrationTest']);

    } catch (error) {
      this.addTestResult('STORAGE_OPERATIONS', false, error.message);
    }
  }

  /**
   * Testa componentes da UI
   */
  async testUIComponents() {
    console.log('üé® Testando componentes da UI...');

    try {
      // Verificar se estamos no popup
      if (window.location.pathname.includes('popup.html')) {
        const requiredElements = [
          'collectJobsBtn',
          'toggleAutoApply',
          'autoApplyBtn',
          'scanPageBtn'
        ];

        let allElementsFound = true;
        const missingElements = [];

        for (const elementId of requiredElements) {
          const element = document.getElementById(elementId);
          if (!element) {
            allElementsFound = false;
            missingElements.push(elementId);
          }
        }

        this.addTestResult('UI_ELEMENTS', allElementsFound,
          allElementsFound ? 'Todos os elementos encontrados' : 
          `Elementos faltando: ${missingElements.join(', ')}`);

      } else {
        this.addTestResult('UI_ELEMENTS', true, 
          'N√£o no popup - teste ignorado');
      }

    } catch (error) {
      this.addTestResult('UI_COMPONENTS', false, error.message);
    }
  }

  /**
   * Adiciona resultado de teste
   */
  addTestResult(testName, passed, message) {
    this.testResults.push({
      name: testName,
      passed: passed,
      message: message,
      timestamp: new Date().toISOString()
    });

    const status = passed ? '‚úÖ' : '‚ùå';
    console.log(`${status} ${testName}: ${message}`);
  }

  /**
   * Gera relat√≥rio final
   */
  generateReport() {
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.passed).length;
    const failedTests = totalTests - passedTests;
    const successRate = totalTests > 0 ? (passedTests / totalTests * 100).toFixed(1) : 0;

    console.log('\nüìä RELAT√ìRIO DE TESTES DE INTEGRA√á√ÉO');
    console.log('=====================================');
    console.log(`Total de testes: ${totalTests}`);
    console.log(`‚úÖ Aprovados: ${passedTests}`);
    console.log(`‚ùå Falharam: ${failedTests}`);
    console.log(`üìà Taxa de sucesso: ${successRate}%`);

    if (failedTests > 0) {
      console.log('\n‚ùå TESTES QUE FALHARAM:');
      this.testResults
        .filter(r => !r.passed)
        .forEach(r => console.log(`  - ${r.name}: ${r.message}`));
    }

    if (successRate >= 80) {
      console.log('\nüéâ Sistema funcionando bem!');
    } else if (successRate >= 60) {
      console.log('\n‚ö†Ô∏è Sistema com alguns problemas');
    } else {
      console.log('\nüö® Sistema com problemas cr√≠ticos');
    }

    // Salvar relat√≥rio
    this.saveTestReport();
  }

  /**
   * Salva relat√≥rio de testes
   */
  async saveTestReport() {
    try {
      const report = {
        timestamp: new Date().toISOString(),
        totalTests: this.testResults.length,
        passedTests: this.testResults.filter(r => r.passed).length,
        failedTests: this.testResults.filter(r => !r.passed).length,
        successRate: this.testResults.length > 0 ? 
          (this.testResults.filter(r => r.passed).length / this.testResults.length * 100).toFixed(1) : 0,
        results: this.testResults
      };

      await chrome.storage.local.set({ 
        integrationTestReport: report 
      });

      console.log('üìÑ Relat√≥rio salvo no storage');

    } catch (error) {
      console.error('Erro ao salvar relat√≥rio:', error);
    }
  }

  /**
   * Executa teste r√°pido
   */
  async quickTest() {
    console.log('‚ö° Executando teste r√°pido...');
    
    const quickTests = [
      () => this.testModuleLoading(),
      () => this.testConfiguration(),
      () => this.testSafetyChecks()
    ];

    for (const test of quickTests) {
      try {
        await test();
      } catch (error) {
        console.error('Erro no teste r√°pido:', error);
      }
    }

    const passed = this.testResults.filter(r => r.passed).length;
    const total = this.testResults.length;
    
    console.log(`‚ö° Teste r√°pido: ${passed}/${total} aprovados`);
    
    return { passed, total };
  }
}

// Exportar para uso global
if (typeof window !== 'undefined') {
  window.WorkInIntegrationTest = WorkInIntegrationTest;
}

// Auto-executar teste r√°pido se estivermos no popup
if (typeof window !== 'undefined' && window.location.pathname.includes('popup.html')) {
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const tester = new WorkInIntegrationTest();
      tester.quickTest();
    }, 2000); // Aguardar 2s para carregar tudo
  });
}
